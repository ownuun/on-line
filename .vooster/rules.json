{
  "rules": [
    {
      "type": "prd",
      "content": "# 디지털 온라인 줄서기 시스템 PRD\n\n## 1. 제품 개요\n콘서트·페스티벌 관객이 행사 이틀 전 모바일 앱으로 파트별(타임 슬롯) 온라인 줄서기를 하고, 행사 당일 실시간 호출 알림에 맞춰 빠르고 편안하게 입장할 수 있도록 돕는 시스템이다.\n\n## 2. 목차\n1. 제품 개요\n2. 목표 & 성공 지표\n3. 페르소나\n4. 핵심 문제(Pain Point)\n5. 핵심 사용 시나리오\n6. 주요 기능\n7. MVP 범위\n8. 추가(부가) 기능\n9. 비-범위(Out of Scope)\n10. 가정 & 리스크\n\n## 3. 목표 & 성공 지표\n| 목표 | 지표(KPI) | 목표값 |\n|------|-----------|--------|\n| 줄서는 시간 최소화 | 평균 현장 대기 시간 | 10분 이하 |\n| 사용자 만족도 향상 | 앱 별점/설문 만족도 | 4.5/5 이상 |\n| 운영 효율화 | 입장 인력 필요 수 | 현행 대비 30% 감소 |\n\n## 4. 페르소나\n- 이름: 지민(25세, 대학생)\n- 특성: 아이돌 콘서트 애호가, 더위에 민감, 모바일 앱 사용에 익숙\n- 목표: 편안하게 입장해 공연을 즐기고 싶다.\n\n## 5. 핵심 문제(Pain Point)\n무더위·추위 등 악천후에서 오래 줄서는 불편을 해소해야 한다.\n\n## 6. 핵심 사용 시나리오\n행사 전 미리 온라인 줄서기 → 행사 당일 호출 알림 → 지정 타임 슬롯에 맞춰 현장 도착 → 번호표 및 티켓·얼굴 인증 → 빠른 입장.\n\n## 7. 주요 기능\n1. 온라인 파트별 줄서기 (타임 슬롯 선택 후 선착순 번호 발급)\n2. 실시간 입장 번호 호출 & 푸시/문자 알림\n3. 티켓 인증 + 얼굴 인식 기반 본인 확인\n4. 파트별 TO(정원) 시뮬레이션 및 권장 수치 계산\n\n## 8. MVP 범위\n- 기능 1~3 전부 구현\n- 간단한 관리자 콘솔(TO 설정, 호출 현황 모니터링)\n- iOS/Android 하이브리드 앱(React Native 기반 예상)\n\n## 9. 추가(부가) 기능\nA. 대기 예상 시간·혼잡도 실시간 표시\nB. 친구와 순번 공유/양도 기능\nC. 현장 맵·부스 안내 및 길찾기\n\n## 10. 비-범위(Out of Scope)\n- 오프라인 키오스크 개발\n- 글로벌 결제·티켓 판매 기능\n- 광고·스폰서 연동 모듈\n\n## 11. 가정 & 리스크\n- 사용자는 스마트폰과 모바일 데이터 환경을 보유한다고 가정\n- 얼굴 인식 오류 시 수동 검수 프로세스 필요\n- 서버 부하(트래픽 폭주) 대비 스케일링 전략 필요\n",
      "writedAt": "2025-08-10T10:45:53.253Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: This project aims to develop a digital online queuing system for concert and festival attendees. The system will allow users to reserve their spot in line two days before the event via a mobile app, receive real-time call notifications on the event day, and facilitate quick and convenient entry through ticket and facial recognition.\n- **Core Technology Stack**: The system will primarily leverage React Native for cross-platform mobile app development, Node.js with Express for the backend API, and MongoDB for data storage. Redis will be used for real-time updates and queue management.\n- **Key Technical Objectives**:\n    - Minimize queuing time: Average on-site wait time below 10 minutes.\n    - Enhance user satisfaction: App rating/survey satisfaction above 4.5/5.\n    - Optimize operational efficiency: Reduce the number of on-site entry staff by 30%.\n- **Critical Technical Assumptions**:\n    - Users possess smartphones with mobile data connectivity.\n    - A manual review process will be available for facial recognition failures.\n    - The system must be scalable to handle potential server load and traffic spikes.\n\n## 2. Tech Stack\n\n| Category             | Technology / Library | Reasoning (Why it's chosen for this project)                                                                             |\n| -------------------- | -------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| Mobile App           | React Native         | Cross-platform development for iOS and Android, aligns with MVP scope and team familiarity, faster development cycle.        |\n| Backend Framework    | Node.js with Express | Scalable, non-blocking I/O, suitable for real-time applications, aligns with JavaScript ecosystem for full-stack development. |\n| Database             | MongoDB              | Flexible schema, suitable for handling diverse event data, scalable for handling large user base.                         |\n| Real-time Updates    | Redis                | In-memory data store, fast read/write operations, ideal for real-time queue management and notifications.                |\n| Authentication       | JSON Web Tokens (JWT) | Secure authentication, stateless, widely adopted for API security.                                                       |\n| Push Notifications   | Firebase Cloud Messaging (FCM) / APNs | Reliable push notification delivery across both Android and iOS platforms.                                             |\n| Face Recognition     | Cloud Vision API (e.g., Google Cloud Vision API) | Scalable, readily available, offloads complex processing, reduces development overhead.                                |\n| API Documentation | Swagger / OpenAPI | Industry standard for designing, building, documenting, and consuming RESTful APIs. |\n| Load Balancing | Nginx | Efficiently distributes incoming network traffic across multiple backend servers. |\n| Infrastructure | AWS / GCP / Azure | Scalable cloud infrastructure for hosting the application and database. |\n| Monitoring | Prometheus & Grafana | Real-time monitoring and alerting for application performance and system health. |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Mobile App (React Native)**:\n    - *Sub-building blocks*: UI components, state management (Redux or Context API), API client, push notification handler, face recognition module, QR code scanner.\n- **Backend API (Node.js with Express)**:\n    - *Sub-building blocks*: RESTful API endpoints, authentication middleware, queue management logic (Redis), database interaction layer (Mongoose), face recognition API integration, admin console API.\n- **Database (MongoDB)**:\n    - *Sub-building blocks*: Event data storage, user data storage, queue status storage, configuration settings.\n- **Real-time Updates (Redis)**:\n    - *Sub-building blocks*: Queue status updates, notification triggers, session management.\n- **Face Recognition API (Cloud Vision API)**:\n    - *Sub-building blocks*: Image analysis, face detection, comparison with stored user images.\n- **Admin Console**:\n    - *Sub-building blocks*: TO settings, call management, monitoring dashboard.\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[Mobile App] --> B(Backend API)\n    B --> C{MongoDB}\n    B --> D{Redis}\n    B --> E[Face Recognition API]\n    F[Admin Console] --> B\n```\n\n- **Mobile App to Backend API**: The mobile app communicates with the backend API via HTTP requests for user authentication, event data retrieval, queue registration, and real-time updates.\n- **Backend API to Database**: The backend API interacts with MongoDB to store and retrieve event data, user information, and queue status.\n- **Backend API to Redis**: The backend API uses Redis for real-time queue management, session management, and notification triggers.\n- **Backend API to Face Recognition API**: The backend API uses Face Recognition API for user face verification during the entry process.\n- **Admin Console to Backend API**: The Admin Console communicates with the backend API via HTTP requests for TO settings and call management.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: Organize code by business domains/bounded contexts (e.g., `user`, `event`, `queue`, `notification`, `admin`).\n- **Layer-Based Architecture**: Separate concerns into distinct layers (presentation, business logic, data access, infrastructure).\n- **Feature-Based Modules**: Group related functionality together rather than separating by technical concerns\n- **Shared Components**: Common utilities, types, and reusable components in dedicated shared modules\n\n**Universal File & Folder Structure**\n```\n/\n├── mobile-app/                # React Native mobile application\n│   ├── src/\n│   │   ├── components/       # Reusable UI components\n│   │   ├── screens/          # App screens/views\n│   │   ├── services/         # API client and data fetching\n│   │   ├── utils/            # Utility functions\n│   │   ├── App.js            # Main application component\n│   │   └── ...\n│   ├── android/              # Android-specific code\n│   ├── ios/                  # iOS-specific code\n│   ├── ...\n├── backend-api/             # Node.js backend API\n│   ├── src/\n│   │   ├── models/           # Mongoose models for MongoDB\n│   │   ├── controllers/      # Route handlers and business logic\n│   │   ├── routes/           # API endpoint definitions\n│   │   ├── services/         # Queue management and notification services\n│   │   ├── config/           # Configuration files\n│   │   ├── app.js            # Main application file\n│   │   └── ...\n├── admin-console/           # Admin console application\n│   ├── ...\n├── documentation/           # API documentation (Swagger/OpenAPI)\n├── scripts/                 # Deployment and utility scripts\n├── ...\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: The mobile app sends HTTP requests to the backend API for all data operations. The backend API responds with JSON data.\n- **Database Interaction**: The backend API uses Mongoose ORM to interact with MongoDB. Data is stored and retrieved using asynchronous operations.\n- **External Service Integration**: The backend API integrates with the Face Recognition API via HTTP requests. API keys and authentication are managed securely.\n- **Real-time Communication**: Redis Pub/Sub is used for real-time updates. When queue status changes, the backend API publishes messages to Redis channels. The mobile app subscribes to these channels to receive updates.\n- **Data Synchronization**: Data consistency is maintained through transactional operations in MongoDB and optimistic locking strategies where appropriate.\n\n## 4. Performance & Optimization Strategy\n- **Database Indexing**: Optimize MongoDB query performance by creating appropriate indexes on frequently queried fields.\n- **Caching**: Implement caching at various levels (e.g., Redis for frequently accessed data, HTTP caching for static assets) to reduce database load and improve response times.\n- **Connection Pooling**: Use connection pooling for database connections to minimize connection overhead.\n- **Load Balancing**: Distribute traffic across multiple backend API instances using a load balancer (e.g., Nginx) to ensure high availability and scalability.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Set up cloud infrastructure (AWS/GCP/Azure), configure database and Redis instances, deploy basic backend API.\n- **Essential Features**: Implement user authentication, online queue registration, basic push notifications, and ticket upload functionality.\n- **Basic Security**: Implement JWT authentication, input validation, and basic protection against common web vulnerabilities.\n- **Development Setup**: Set up development environment, CI/CD pipeline for automated builds and deployments.\n- **Timeline**: 8 weeks\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: Implement face recognition integration, real-time queue status updates, admin console for TO settings and call management.\n- **Performance Optimization**: Optimize database queries, implement caching, and configure load balancing.\n- **Enhanced Security**: Implement rate limiting, DDoS protection, and regular security audits.\n- **Monitoring Implementation**: Set up Prometheus and Grafana for real-time monitoring and alerting.\n- **Timeline**: 6 weeks\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Complexity of integrating face recognition API, potential performance issues with real-time updates.\n    - **Mitigation Strategies**: Thoroughly test face recognition integration, optimize Redis configuration, and implement load shedding mechanisms.\n- **Performance Risks**: Scalability issues during peak traffic, database bottlenecks.\n    - **Mitigation Strategies**: Implement auto-scaling for backend API instances, optimize database queries, and use caching.\n- **Security Risks**: Vulnerabilities in authentication and authorization mechanisms, potential for data breaches.\n    - **Mitigation Strategies**: Conduct regular security audits, implement strong password policies, and encrypt sensitive data.\n- **Integration Risks**: Third-party API dependencies and failure points.\n    - **Mitigation Strategies**: Implement fallback mechanisms, monitor API availability, and have alternative solutions ready.\n\n### Project Delivery Risks\n- **Timeline Risks**: Delays in development due to technical challenges or resource constraints.\n    - **Contingency Plans**: Prioritize critical features, allocate additional resources, and adjust project scope if necessary.\n- **Resource Risks**: Lack of skilled developers with experience in React Native, Node.js, and MongoDB.\n    - **Contingency Plans**: Provide training for existing team members, hire external consultants, and outsource development tasks.\n- **Quality Risks**: Code quality issues, lack of thorough testing.\n    - **Contingency Plans**: Implement code reviews, automate testing, and allocate sufficient time for quality assurance.\n- **Deployment Risks**: Issues with production deployment and environment configuration.\n    - **Contingency Plans**: Use infrastructure-as-code tools, automate deployment processes, and have a rollback plan in place.\n",
      "writedAt": "2025-08-10T10:45:53.253Z"
    },
    {
      "type": "guideline",
      "content": "```markdown\n# Digital Online Queuing System - Code Guidelines\n\n## 1. Project Overview\n\nThis project develops a digital online queuing system for concert and festival attendees using React Native for the mobile app, Node.js with Express for the backend API, MongoDB for data storage, and Redis for real-time updates.\n\nKey architectural decisions include a microservice-inspired approach with clear separation of concerns, RESTful API design, and leveraging cloud-based services for scalability and maintainability.\n\n## 2. Core Principles\n\n-   **Maintainability**: Code should be easily understood and modified by any team member.\n-   **Scalability**: The system must be able to handle increasing user load without performance degradation.\n-   **Testability**: Code should be written in a way that facilitates unit and integration testing.\n-   **Security**: Implement secure coding practices to protect user data and prevent vulnerabilities.\n-   **Efficiency**: Code should be optimized for performance and resource utilization.\n\n## 3. Language-Specific Guidelines\n\n### 3.1. JavaScript (React Native & Node.js)\n\n#### 3.1.1. File Organization and Directory Structure\n\n-   **React Native:**\n    ```\n    /src\n    ├── components/         # Reusable UI components\n    ├── screens/            # App screens/views\n    ├── services/          # API client and data fetching\n    ├── utils/             # Utility functions\n    ├── navigation/        # Navigation logic\n    ├── App.js              # Main application component\n    ```\n\n-   **Node.js:**\n    ```\n    /src\n    ├── models/            # Mongoose models for MongoDB\n    ├── controllers/       # Route handlers and business logic\n    ├── routes/            # API endpoint definitions\n    ├── services/          # Business logic and data access\n    ├── config/            # Configuration files\n    ├── middleware/        # Custom middleware\n    ├── utils/             # Utility functions\n    ├── app.js             # Main application file\n    ```\n\n#### 3.1.2. Import/Dependency Management\n\n-   Use `npm` or `yarn` for dependency management.\n-   Explicitly declare all dependencies in `package.json`.\n-   Use semantic versioning (semver) for dependencies.\n-   Avoid wildcard imports (`import * as ...`) to improve readability and reduce namespace pollution.\n-   Organize imports alphabetically within each group (e.g., built-in modules, third-party libraries, local modules).\n\n    ```javascript\n    // MUST: Example of organized imports\n\n    // Built-in modules\n    const fs = require('fs');\n    const path = require('path');\n\n    // Third-party libraries\n    const express = require('express');\n    const mongoose = require('mongoose');\n\n    // Local modules\n    const config = require('./config');\n    const userRoutes = require('./routes/userRoutes');\n    ```\n\n#### 3.1.3. Error Handling Patterns\n\n-   Use `try...catch` blocks for handling synchronous errors.\n-   Use `async/await` with `try...catch` for asynchronous errors.\n-   Implement centralized error handling middleware in Node.js to catch unhandled exceptions.\n-   Log errors with sufficient context (e.g., request ID, user ID, timestamp).\n-   Return meaningful error messages to the client.\n-   Differentiate between operational errors (e.g., invalid user input) and programming errors (e.g., null reference).\n\n    ```javascript\n    // MUST: Example of async/await with try...catch\n\n    async function getUser(userId) {\n        try {\n            const user = await User.findById(userId);\n            if (!user) {\n                throw new Error('User not found');\n            }\n            return user;\n        } catch (error) {\n            console.error('Error fetching user:', error);\n            throw error; // Re-throw the error to be handled by the error middleware\n        }\n    }\n    ```\n\n### 3.2. MongoDB (Mongoose)\n\n#### 3.2.1. Schema Definition\n\n-   Define clear and concise schemas for all data models.\n-   Use appropriate data types for each field.\n-   Define indexes for frequently queried fields to improve performance.\n-   Use timestamps (`createdAt`, `updatedAt`) for tracking data changes.\n-   Use virtuals for computed properties that are not stored in the database.\n\n    ```javascript\n    // MUST: Example of Mongoose schema definition\n\n    const mongoose = require('mongoose');\n\n    const userSchema = new mongoose.Schema({\n        username: { type: String, required: true, unique: true },\n        email: { type: String, required: true, unique: true },\n        password: { type: String, required: true },\n        createdAt: { type: Date, default: Date.now },\n        updatedAt: { type: Date, default: Date.now }\n    });\n\n    userSchema.index({ username: 1 }); // Create an index on the username field\n\n    const User = mongoose.model('User', userSchema);\n\n    module.exports = User;\n    ```\n\n#### 3.2.2. Data Validation\n\n-   Use Mongoose's built-in validation features to ensure data integrity.\n-   Define custom validation functions for complex validation logic.\n-   Handle validation errors gracefully and return meaningful error messages to the client.\n\n    ```javascript\n    // MUST: Example of Mongoose data validation\n\n    const mongoose = require('mongoose');\n\n    const eventSchema = new mongoose.Schema({\n        name: {\n            type: String,\n            required: [true, 'Event name is required'],\n            maxlength: [100, 'Event name cannot exceed 100 characters']\n        },\n        date: {\n            type: Date,\n            required: [true, 'Event date is required'],\n            validate: {\n                validator: function(value) {\n                    return value > Date.now(); // Ensure event date is in the future\n                },\n                message: 'Event date must be in the future'\n            }\n        }\n    });\n\n    const Event = mongoose.model('Event', eventSchema);\n\n    module.exports = Event;\n    ```\n\n### 3.3. Redis\n\n#### 3.3.1. Data Structures\n\n-   Use appropriate Redis data structures (e.g., strings, lists, sets, sorted sets, hashes) for different use cases.\n-   Use strings for simple key-value storage.\n-   Use lists for queues and ordered collections.\n-   Use sets for storing unique values.\n-   Use sorted sets for leaderboards and ranking.\n-   Use hashes for storing objects.\n\n#### 3.3.2. Connection Management\n\n-   Use a connection pool to reuse connections and reduce connection overhead.\n-   Handle connection errors gracefully.\n-   Implement reconnection logic to automatically reconnect to Redis if the connection is lost.\n\n## 4. Code Style Rules\n\n### 4.1. MUST Follow:\n\n-   **Naming Conventions:**\n    -   Use camelCase for variable and function names (e.g., `userName`, `getUserById`).\n    -   Use PascalCase for class and component names (e.g., `User`, `UserProfile`).\n    -   Use SCREAMING_SNAKE_CASE for constants (e.g., `MAX_USERS`).\n    -   Filenames should match the name of the primary export.\n    -   Rationale: Consistent naming improves readability and maintainability.\n\n-   **Indentation:**\n    -   Use 2 spaces for indentation.\n    -   Rationale: Consistent indentation improves readability and reduces visual clutter.\n\n-   **Line Length:**\n    -   Limit line length to 120 characters.\n    -   Rationale: Improves readability and prevents horizontal scrolling.\n\n-   **Comments:**\n    -   Write clear and concise comments to explain complex logic.\n    -   Document all public APIs and functions.\n    -   Use JSDoc syntax for documenting JavaScript code.\n    -   Rationale: Comments help other developers understand the code and its purpose.\n\n-   **Error Handling:**\n    -   Always handle errors gracefully.\n    -   Log errors with sufficient context.\n    -   Return meaningful error messages to the client.\n    -   Rationale: Proper error handling prevents unexpected crashes and provides valuable debugging information.\n\n-   **Asynchronous Operations:**\n    -   Use `async/await` for asynchronous operations.\n    -   Handle errors in asynchronous operations with `try...catch` blocks.\n    -   Rationale: `async/await` makes asynchronous code easier to read and reason about.\n\n-   **Security:**\n    -   Sanitize user input to prevent XSS attacks.\n    -   Use parameterized queries to prevent SQL injection attacks.\n    -   Store passwords securely using bcrypt or similar hashing algorithms.\n    -   Rationale: Security is paramount to protect user data and prevent vulnerabilities.\n\n-   **Testing:**\n    -   Write unit tests for all critical functions and components.\n    -   Write integration tests to ensure that different parts of the system work together correctly.\n    -   Rationale: Testing helps to prevent bugs and ensure that the system works as expected.\n\n### 4.2. MUST NOT Do:\n\n-   **Global Variables:**\n    -   Avoid using global variables.\n    -   Rationale: Global variables can lead to naming conflicts and make it difficult to reason about the code.\n\n    ```javascript\n    // MUST NOT: Example of using a global variable\n\n    // BAD:\n    global.userName = 'John Doe';\n\n    function greetUser() {\n        console.log('Hello, ' + global.userName);\n    }\n    ```\n\n-   **Magic Numbers:**\n    -   Avoid using magic numbers (unexplained numeric literals).\n    -   Define constants for all numeric literals.\n    -   Rationale: Constants make the code more readable and easier to maintain.\n\n    ```javascript\n    // MUST NOT: Example of using a magic number\n\n    // BAD:\n    function calculateArea(radius) {\n        return 3.14 * radius * radius; // What is 3.14?\n    }\n\n    // GOOD:\n    const PI = 3.14;\n    function calculateArea(radius) {\n        return PI * radius * radius;\n    }\n    ```\n\n-   **Nested Callbacks:**\n    -   Avoid deeply nested callbacks (callback hell).\n    -   Use `async/await` or Promises to flatten asynchronous code.\n    -   Rationale: Nested callbacks make the code difficult to read and maintain.\n\n    ```javascript\n    // MUST NOT: Example of nested callbacks\n\n    // BAD:\n    fs.readFile('file1.txt', (err, data1) => {\n        if (err) {\n            console.error(err);\n        } else {\n            fs.readFile('file2.txt', (err, data2) => {\n                if (err) {\n                    console.error(err);\n                } else {\n                    // ... more nested callbacks\n                }\n            });\n        }\n    });\n    ```\n\n-   **Ignoring Errors:**\n    -   Never ignore errors.\n    -   Always handle errors gracefully and log them with sufficient context.\n    -   Rationale: Ignoring errors can lead to unexpected crashes and make it difficult to debug the code.\n\n    ```javascript\n    // MUST NOT: Example of ignoring an error\n\n    // BAD:\n    fs.readFile('file.txt', (err, data) => {\n        // Ignoring the error\n        console.log(data);\n    });\n    ```\n\n-   **Complex Conditional Statements:**\n    -   Avoid overly complex conditional statements.\n    -   Break down complex conditions into smaller, more manageable functions.\n    -   Rationale: Complex conditional statements make the code difficult to read and understand.\n\n    ```javascript\n    // MUST NOT: Example of a complex conditional statement\n\n    // BAD:\n    if (user.age > 18 && user.isVerified && user.hasAcceptedTerms && (user.country === 'US' || user.country === 'CA')) {\n        // ...\n    }\n    ```\n\n-   **Duplicated Code:**\n    -   Avoid duplicating code.\n    -   Extract common logic into reusable functions or components.\n    -   Rationale: Duplicated code makes the code more difficult to maintain and increases the risk of bugs.\n\n    ```javascript\n    // MUST NOT: Example of duplicated code\n\n    // BAD:\n    function processOrder(order) {\n        // ... some logic\n        console.log('Order processed');\n    }\n\n    function processPayment(payment) {\n        // ... same logic as processOrder\n        console.log('Payment processed');\n    }\n    ```\n\n## 5. Architecture Patterns\n\n### 5.1. Component/Module Structure Guidelines\n\n-   **React Native:**\n    -   Use functional components with hooks for state management and side effects.\n    -   Separate UI components from business logic.\n    -   Use a consistent component structure (e.g., `index.js`, `ComponentName.js`, `ComponentName.styles.js`).\n\n-   **Node.js:**\n    -   Use a modular architecture with clear separation of concerns.\n    -   Separate controllers, services, models, and routes into different modules.\n    -   Use dependency injection to decouple modules.\n\n### 5.2. Data Flow Patterns\n\n-   **React Native:**\n    -   Use unidirectional data flow with state managed by Redux or Context API.\n    -   Components should only update state through actions or context updates.\n\n-   **Node.js:**\n    -   Use a request-response cycle for handling API requests.\n    -   Data flows from the client to the controller, then to the service, then to the model, and finally to the database.\n\n### 5.3. State Management Conventions (React Native)\n\n-   Use Redux or Context API for managing application state.\n-   Define clear and concise actions for updating state.\n-   Use reducers to handle state updates in a predictable way.\n-   Use selectors to access state data in a performant way.\n\n### 5.4. API Design Standards\n\n-   Follow RESTful API principles.\n-   Use meaningful and consistent endpoint names.\n-   Use HTTP status codes to indicate the success or failure of a request.\n-   Return JSON data in a consistent format.\n-   Implement pagination for large datasets.\n-   Use versioning for APIs to maintain backward compatibility.\n-   Document APIs using Swagger/OpenAPI.\n\n    ```\n    // MUST: Example of RESTful API endpoint\n\n    GET /users         // Get all users\n    GET /users/:id     // Get a specific user by ID\n    POST /users        // Create a new user\n    PUT /users/:id     // Update an existing user\n    DELETE /users/:id  // Delete a user\n    ```\n```",
      "writedAt": "2025-08-10T10:45:53.253Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-10T10:45:53.253Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-10T10:45:53.253Z"
    }
  ]
}